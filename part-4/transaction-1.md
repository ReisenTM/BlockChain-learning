# 交易

---
## 结构
UTXO 模型是比特币等加密货币使用的一种账户模型，全称是：

`Unspent Transaction Output（未花费交易输出）模型`

⸻

🌟 简单解释：

在 UTXO 模型中，没有账户余额的概念。取而代之的是：

    你的“余额” = 你拥有的 所有未花费的交易输出（UTXO） 之和。


区块链里一次交易需要前一次交易的输出作为输入之一，同时有输入必须要有输出
## 交易输入输出
#### 输出
```go
type TXOutput struct {
    Value        int //一定量的比特币
    ScriptPubKey string //脚本
}
```
输出主要包含两部分：
- 一定量的比特币(Value)
- 一个锁定脚本(ScriptPubKey)，要花这笔钱，必须要解锁该脚本。
> 事实上，正是输出里存储了"币"，这里的储存指的是用一个数学难题对输出进行锁定，这个难题被存储在`ScriptPubKey`内

*在比特币中，value 字段存储的是 `satoshi` 的数量，而不是 BTC 的数量。一个 satoshi 等于一亿分之一的 BTC(0.00000001 BTC)，这也是比特币里面最小的货币单位。*

#### 输入
```go
type TXInput struct {
	Txid      []byte //前一次交易的id
	Vout      int   //存储的是该输出在那笔交易中所有输出中的索引
	ScriptSig string//ScriptSig 是一个脚本，提供了可解锁输出结构里面 ScriptPubKey 字段的数据
}
```

既然输出依赖于输入，那么这不得不引入一个问题:现有鸡(输入)还是先有蛋(输出)呢？
- 事实上先有输出

当矿工挖出一个新的块时，它会向新的块中添加一个 `coinbase` 交易。coinbase 交易是一种特殊的交易，它不需要引用之前一笔交易的输出。它“凭空”产生了币（也就是产生了新币），这是矿工获得挖出新块的奖励，也可以理解为“发行新币”。
> 这也就是所谓的`挖矿`


我们使用拼接交易hash再统一取hash，但
比特币使用了一个更加复杂的技术：它将一个块里面包含的所有交易表示为一个  Merkle tree ，然后在工作量证明系统中使用树的根哈希（root hash）。这个方法能够让我们快速检索一个块里面是否包含了某笔交易，即只需 root hash 而无需下载所有交易即可完成判断。
## 余额

我们需要找到所有的未花费交易输出（unspent transactions outputs, UTXO）。未花费（unspent） 指的是这个输出还没有被包含在任何交易的输入中，或者说没有被任何输入引用。

## 总结

在本次实现中，每个交易都要单独占用一个区块，这是相当低效的

我们在后续会实现
`内存池（mempool）`:在交易被打包到块之前，这些交易被存储在内存池里面。




